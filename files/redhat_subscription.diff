--- /tmp/redhat_subscription.py	2016-02-19 17:48:19.376702612 +0000
+++ /tmp/patched_redhat_subscription.py.txt	2016-02-19 17:49:55.950734467 +0000
@@ -186,7 +186,7 @@
         for k,v in kwargs.items():
             if re.search(r'^(system|rhsm)_', k):
                 args.append('--%s=%s' % (k.replace('_','.'), v))
-        
+
         self.module.run_command(args, check_rc=True)
 
     @property
@@ -232,14 +232,26 @@
 
         rc, stderr, stdout = self.module.run_command(args, check_rc=True)
 
-    def unsubscribe(self):
+    def unsubscribe(self, serials=None):
         '''
-            Unsubscribe a system from all subscribed channels
+            Unsubscribe a system from subscribed channels
+            Args:
+              serials(list or None): list of serials to unsubscribe. If
+                                     serials is none or an empty list, then
+                                     all subscribed channels will be removed.
             Raises:
               * Exception - if error occurs while running command
         '''
-        args = ['subscription-manager', 'unsubscribe', '--all']
-        rc, stderr, stdout = self.module.run_command(args, check_rc=True)
+        items = []
+        if serials is not None and serials:
+            items = ["--serial=%s" % s for s in serials]
+        if serials is None:
+            items = ["--all"]
+
+        if items:
+            args = ['subscription-manager', 'unsubscribe'] + items
+            rc, stderr, stdout = self.module.run_command(args, check_rc=True)
+        return serials
 
     def unregister(self):
         '''
@@ -261,8 +273,27 @@
         # Available pools ready for subscription
         available_pools = RhsmPools(self.module)
 
+        subscribed_pool_ids = []
         for pool in available_pools.filter(regexp):
             pool.subscribe()
+            subscribed_pool_ids.append(pool.get_pool_id())
+        return subscribed_pool_ids
+
+    def update_subscriptions(self, regexp):
+        changed=False
+        consumed_pools = RhsmPools(self.module, consumed=True)
+        pool_ids_to_keep = [p.get_pool_id() for p in consumed_pools.filter(regexp)]
+
+        serials_to_remove=[p.Serial for p in consumed_pools if p.get_pool_id() not in pool_ids_to_keep]
+        serials = self.unsubscribe(serials=serials_to_remove)
+
+        subscribed_pool_ids = self.subscribe(regexp)
+
+        if subscribed_pool_ids or serials:
+            changed=True
+        return {'changed': changed, 'subscribed_pool_ids': subscribed_pool_ids,
+                'unsubscribed_serials': serials}
+
 
 
 class RhsmPool(object):
@@ -278,8 +309,11 @@
     def __str__(self):
         return str(self.__getattribute__('_name'))
 
+    def get_pool_id(self):
+        return getattr(self, 'PoolId', getattr(self, 'PoolID'))
+
     def subscribe(self):
-        args = "subscription-manager subscribe --pool %s" % self.PoolId
+        args = "subscription-manager subscribe --pool %s" % self.get_pool_id()
         rc, stdout, stderr = self.module.run_command(args, check_rc=True)
         if rc == 0:
             return True
@@ -291,18 +325,25 @@
     """
         This class is used for manipulating pools subscriptions with RHSM
     """
-    def __init__(self, module):
+    def __init__(self, module, consumed=False):
         self.module = module
-        self.products = self._load_product_list()
+        self.products = self._load_product_list(consumed)
 
     def __iter__(self):
         return self.products.__iter__()
 
-    def _load_product_list(self):
+    def _load_product_list(self, consumed=False):
         """
-            Loads list of all available pools for system in data structure
+            Loads list of all available or consumed pools for system in data structure
+
+            Args:
+                consumed(bool): if True list consumed  pools, else list available pools (default False)
         """
-        args = "subscription-manager list --available"
+        args = "subscription-manager list"
+        if consumed:
+            args += " --consumed"
+        else:
+            args += " --available"
         rc, stdout, stderr = self.module.run_command(args, check_rc=True)
 
         products = []
